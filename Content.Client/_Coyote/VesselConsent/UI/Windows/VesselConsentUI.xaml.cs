using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;

namespace Content.Client._COYOTE.VesselConsent.UI.Windows;

[GenerateTypedNameReferences]
public sealed partial class VesselConsentUI : FancyWindow
{
    private readonly VesselConsentSystem _vesselConsent;

    public VesselConsentUI()
    {
        RobustXamlLoader.Load(this);

        // This sucks. There has got to be a cleverer way to interact with a system in a UI,
        // but I don't fully understand how. At the very least, this won't be called much.
        _vesselConsent = IoCManager.Resolve<IEntitySystemManager>().GetEntitySystem<VesselConsentSystem>();

        _vesselConsent.OnConsentStatusChange += UpdateUi;
        _vesselConsent.OnVesselConditionsChange += UpdateUi;

        Save.OnPressed += args => SaveChanges();
        ToggleButton.OnPressed += args => ToggleConsent();
        UpdateUi();
    }

    public void UpdateUi()
    {
        if (!_vesselConsent.VesselConsentState.HasValue)
        {
            // Consent system is not applicable, the player is not on a private vessel
            VesselConditionsText.Editable = false;
            VesselConditionsText.TextRope = new Rope.Leaf(Loc.GetString("vessel-consent-not-applicable"));

            Explanation.Text = Loc.GetString("vessel-consent-explanation-not-owned");

            Feedback.Text = Loc.GetString("vessel-consent-feedback-not-applicable");
            Feedback.AddStyleClass(StyleNano.StyleClassLabelSecondaryColor);

            Save.Disabled = true;

            ToggleButton.Disabled = true;
        }
        else
        {
            // Consent system is applicable
            var desc = _vesselConsent.CurrentVesselDescription ?? string.Empty;
            ToggleButton.Disabled = desc.Length == 0;

            if (_vesselConsent.OwnsCurrentVessel())
            {
                VesselConditionsText.Editable = true;
                VesselConditionsText.TextRope = new Rope.Leaf(desc);
                VesselConditionsText.Placeholder = new Rope.Leaf(Loc.GetString("vessel-consent-placeholder"));
                Explanation.Text = Loc.GetString("vessel-consent-explanation-owned");

                Save.Disabled = false;
            }
            else
            {
                VesselConditionsText.Editable = false;
                VesselConditionsText.TextRope =  new Rope.Leaf(desc.Length == 0 ? Loc.GetString("vessel-consent-none-specified") : desc);
                Explanation.Text = Loc.GetString("vessel-consent-explanation-not-owned");

                Save.Disabled = true;
            }

            Feedback.Text = _vesselConsent.VesselConsentState.Value
                ? Loc.GetString("vessel-consent-feedback-consenting")
                : Loc.GetString("vessel-consent-feedback-non-consenting");
            Feedback.RemoveStyleClass(StyleNano.StyleClassLabelSecondaryColor);

            ToggleButton.Text = _vesselConsent.ConsentsToCurrentVessel()
                ? Loc.GetString("vessel-consent-revoke")
                : Loc.GetString("vessel-consent-consent");

            // Not sure about the semantics of making it red for revoke but different color is nice
            if (_vesselConsent.ConsentsToCurrentVessel())
            {
                ToggleButton.AddStyleClass(StyleNano.StyleClassButtonColorRed);
            }
            else
            {
                ToggleButton.RemoveStyleClass(StyleNano.StyleClassButtonColorRed);
            }
        }
    }

    private void SaveChanges()
    {
        _vesselConsent.UpdateCurrentVesselConditions(Rope.Collapse(VesselConditionsText.TextRope));
    }

    // Given that this is not predicted, being a toggle might be awkward.
    // TODO: Test on high latency
    private void ToggleConsent()
    {
        if (_vesselConsent.CurrentVesselConditionsId is { } id)
            _vesselConsent.UpdateOwnVesselConsent(!_vesselConsent.ConsentsToCurrentVessel(), id);
    }
}
